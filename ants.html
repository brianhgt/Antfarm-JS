<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Antfarm JS</title>
<style>
  body {
  margin: 0;
  background: #333;
  color: #fff;
  font-family: sans-serif;
  overflow: hidden; /* prevent scrollbars */
}

canvas {
  position: absolute;
  top: 0;
  left: 0;
  image-rendering: pixelated;
  display: block;
}
h3 { text-align:center; }
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
<h3>üêú Antfarm JS üêú</h3>
<canvas id="bg" class="gameCanvas"></canvas>
<canvas id="fg" class="gameCanvas"></canvas>
<canvas id="dbg" class="gameCanvas"></canvas>
<script>
var jq = jQuery.noConflict();

jq(function(){
//const canvas = jq("#gameCanvas")[0];
//const ctx = canvas.getContext("2d");
const showDebug = true;

const bgCanvas = document.getElementById("bg");
bgCanvas.width = window.innerWidth;
bgCanvas.height = window.innerHeight;
const fgCanvas = document.getElementById("fg");
fgCanvas.width = window.innerWidth;
fgCanvas.height = window.innerHeight;
const dbgCanvas = document.getElementById("dbg");
dbgCanvas.width = window.innerWidth;
dbgCanvas.height = window.innerHeight;

const TILE_SIZE = 20, COLS=Math.floor(bgCanvas.width/TILE_SIZE), ROWS=Math.floor(bgCanvas.height/TILE_SIZE);
const canvasWidth = COLS * TILE_SIZE;
const canvasHeight = ROWS * TILE_SIZE;

bgCanvas.width = fgCanvas.width = canvasWidth;
bgCanvas.height = fgCanvas.height = canvasHeight;
dbgCanvas.height = fgCanvas.height = canvasHeight;

const bgCtx = bgCanvas.getContext("2d");
const fgCtx = fgCanvas.getContext("2d");
const dbgCtx = dbgCanvas.getContext("2d");

const TILE={ EMPTY:0, DIRT:1, FOOD:2, NEST:3, EGG:4 };
const ANT_TYPE = { QUEEN:0, WORKER:1, SOLDIER:2, FEMALE:3, MALE:4 };
const TILE_OPEN_SPACE = 10;
const SPIDER_CAN_GO_BELOW = false;
const WANDER_DIST = 6;
const EGG_HATCH_TIME = 1000;
const SPIDER_COOLDOWN = 5 * 60; //frames ~Xs * 60fps
const FOOD_SPAWN_INTERVAL = 20 * 60; //frames ~Xs * 60fps
let foodSpawnTimer=FOOD_SPAWN_INTERVAL;
const FOOD_GROUP_SIZE=5;

const keys={}; // track keys
jq(document).keydown(e=>keys[e.key]=true);
jq(document).keyup(e=>keys[e.key]=false);


const NUM_SPIDERS = 1;
const INIT_NUM_FOOD = 30;
const map=[];
for(let y=0;y<ROWS;y++){
  let row=[]; for(let x=0;x<COLS;x++) row.push(y<TILE_OPEN_SPACE?TILE.EMPTY:TILE.DIRT);
  map.push(row);
}

// initial food on surface
let foods = new Map();
for(let i=0;i<INIT_NUM_FOOD;i++){
  let fx=Math.floor(Math.random()*COLS);
  let fy=Math.floor(Math.random()*TILE_OPEN_SPACE);
  foods.set(get2dHash(fx, fy), {x:fx,y:fy,carry:false});
}

let spiderScore=0;
const colonies=[
  {name:"A", color:"black", nest:{}, eggs:new Map(), workers:[], soldiers:[], player:{}, score:0, playerTarget:null},
  {name:"B", color:"red", nest:{}, eggs:new Map(), workers:[], soldiers:[], player:{}, score:0, playerTarget:null}
];


const spiders=[{x:4,y:2,target:null,path:null,pathIndex:0, timer:EGG_HATCH_TIME, cooldownTimer:SPIDER_COOLDOWN},
   {x:COLS-4,y:2,target:null,path:null,pathIndex:0, timer:EGG_HATCH_TIME, cooldownTimer:SPIDER_COOLDOWN}];
const skulls=[];

colonies.forEach((col)=>{
  let nx=0, ny=0;
  do{
    //subtract 2 for egg spawn distance
    nx = 2 + Math.floor(Math.random()*(COLS - 4));
    ny = 2 + TILE_OPEN_SPACE + Math.floor(Math.random()*(ROWS - TILE_OPEN_SPACE - 4));
  }while(map[ny][nx]!=TILE.DIRT);
  map[ny][nx]=TILE.NEST;
  map[ny + 1][nx]=TILE.NEST;
  col.nest={x:nx, y:ny, sX:nx, sY:ny+1};
  
  //place player
  col.player={x:nx+0.5, y:ny+0.5, carrying:null};
  
  // spawn egg
  let ex = nx+1, ey = ny;
  if(map[ey][ex] == TILE.DIRT) {
    map[ey][ex] = TILE.EMPTY;
    col.eggs.set(get2dHash(ex, ey), {x:ex, y:ey, type:ANT_TYPE.WORKER, timer:EGG_HATCH_TIME, carry:false});
  }
});

// click-to-move
jq(fgCanvas).click(e=>{
  const rect=fgCanvas.getBoundingClientRect();
  const mx=(e.clientX-rect.left)/TILE_SIZE;
  const my=(e.clientY-rect.top)/TILE_SIZE;
  colonies[0].playerTarget={x:mx, y:my};
});




function update(){
  foodSpawnTimer--;
  if(foodSpawnTimer<=0){
    foodSpawnTimer=FOOD_SPAWN_INTERVAL;
    for(let i=0;i<FOOD_GROUP_SIZE;i++){
      let fx=Math.floor(Math.random()*COLS);
      let fy=Math.floor(Math.random()*TILE_OPEN_SPACE);
      foods.set(get2dHash(fx, fy), {x:fx,y:fy});
    }
  }

  // eggs hatch
  /*
  for(let i=eggs.length-1;i>=0;i--){
    eggs[i].timer--;
    if(eggs[i].timer<=0){
      let col=colonies.find(c=>c.name==eggs[i].colony);
      col.workers.push({x:eggs[i].x+0.5, y:eggs[i].y+0.5, path:null, pathIndex:0});
      map[eggs[i].y][eggs[i].x]=TILE.EMPTY;
      eggs.splice(i,1);
    }
  }
  */
	
    // keyboard
	let dx=0, dy=0;
	let ex=0, ey=0;
	
	//player 1
	if(keys['a'])dx=-0.1;
	if(keys['d'])dx=0.1;
	if(keys['w'])dy=-0.1;
	if(keys['s'])dy=0.1;
	
	colonies[0].player.x=Math.max(0,Math.min(COLS-1,colonies[0].player.x+dx));
	colonies[0].player.y=Math.max(0,Math.min(ROWS-1,colonies[0].player.y+dy));
	
	// pickup/drop with 'e'
	if(keys['e']){
		keys['e']=false; // prevent repeat
		let tx=Math.floor(colonies[0].player.x), ty=Math.floor(colonies[0].player.y);
		if(!colonies[0].player.carrying){
		  if(map[ty][tx]==TILE.FOOD || map[ty][tx]==TILE.EGG){
			colonies[0].player.carrying=map[ty][tx];
			map[ty][tx]=TILE.EMPTY;
		  }
		}else{
		  if(map[ty][tx]==TILE.EMPTY){
			map[ty][tx] = colonies[0].player.carrying;
			colonies[0].player.carrying = null;
		  }
		}
	}
	

	//player 2
	if(keys['ArrowLeft'])ex = -0.1;
	if(keys['ArrowRight'])ex = 0.1;
	if(keys['ArrowUp'])ey = -0.1;
	if(keys['ArrowDown'])ey = 0.1;
	colonies[1].player.x=Math.max(0,Math.min(COLS-1,colonies[1].player.x+ex));
	colonies[1].player.y=Math.max(0,Math.min(ROWS-1,colonies[1].player.y+ey));
		

   colonies.forEach((col,idx)=>{
  
      //hatch eggs
      col.eggs.forEach(egg=>{
         if(egg) {
            egg.timer--;
            if(egg.timer <= 0) {
               if(egg.type == ANT_TYPE.SOLDIER) {
                  col.soldiers.push({x:egg.x+0.5, y:egg.y+0.5, path:null, pathIndex:0, type:ANT_TYPE.SOLDIER});
               }
               else {
                  col.workers.push({x:egg.x+0.5, y:egg.y+0.5, path:null, pathIndex:0, type:ANT_TYPE.WORKER});
               }
               //map[col.eggs[i].y][col.eggs[i].x] = TILE.EMPTY;
               col.eggs.delete(get2dHash(egg.x, egg.y));
            }
         }
      });
      /*
      for(let i = col.eggs.length-1; i >= 0; i--) {
         col.eggs[i].timer--;
         if(col.eggs[i].timer<=0){
            if(col.eggs[i].type == ANT_TYPE.SOLDIER) {
               col.soldiers.push({x:col.eggs[i].x+0.5, y:col.eggs[i].y+0.5, path:null, pathIndex:0, type:ANT_TYPE.SOLDIER});
            }
            else {
               col.workers.push({x:col.eggs[i].x+0.5, y:col.eggs[i].y+0.5, path:null, pathIndex:0, type:ANT_TYPE.WORKER});
            }
            //map[col.eggs[i].y][col.eggs[i].x] = TILE.EMPTY;
            col.eggs.splice(i,1);
         }
      }
      */
      
      //hatch spiders
      for(let i = spiders.length-1; i >= 0; i--) {
         if(spiders[i].timer >= 0) {
            spiders[i].timer--;
         }
         if(spiders[i].cooldownTimer >= 0) {
            spiders[i].cooldownTimer--;
         }
      }
        
      
       let player = col.player;
       


       // click target
       if(col.playerTarget){
         let ddx=col.playerTarget.x - player.x, ddy=col.playerTarget.y - player.y;
         let dist=Math.sqrt(ddx*ddx+ddy*ddy);
         if(dist>0.1) player.x+=0.1*ddx/dist, player.y+=0.1*ddy/dist;
         else col.playerTarget=null;
       }

      let tx=Math.floor(player.x), ty=Math.floor(player.y);
      //dig
      if(map[ty][tx]==TILE.DIRT) {
         map[ty][tx]=TILE.EMPTY;
         drawBackground(bgCtx);
      }
      //pickup Egg
      if(!player.carrying && (col.eggs[get2dHash(tx, ty)])){
         player.carrying=TILE.EGG;
         col.eggs[get2dHash(tx, ty)].carry = true;
         //map[ty][tx]=TILE.EMPTY;
      }
      //pickup food
      else if (!player.carrying && (foods.get(get2dHash(tx, ty)))){
         player.carrying = TILE.FOOD;
         foods.delete(get2dHash(tx, ty));
      }
         
      //spawn worker
      if(tx==col.nest.x&&ty==col.nest.y && player.carrying){
         if(player.carrying==TILE.FOOD){ player.score++; spawnEggNearNest(col, ANT_TYPE.WORKER); }
         if(player.carrying==TILE.EGG){
            col.workers.push({x:col.nest.x, y:col.nest.y, carrying:null, target:null, path:null, pathIndex:0, type:ANT_TYPE.WORKER});
         }
         player.carrying=null;
      }
      //spawn soldier
      if(tx==col.nest.sX&&ty==col.nest.sY && player.carrying) {
         if(player.carrying==TILE.FOOD){ player.score++; spawnEggNearNest(col, ANT_TYPE.SOLDIER); }
         if(player.carrying==TILE.EGG) {
            col.soldiers.push({x:col.nest.sX, y:col.nest.sY, carrying:null, target:null, path:null, pathIndex:0, type:ANT_TYPE.SOLDIER});
         }
         player.carrying=null;
      }

      // workers: find food
      col.workers.forEach(ant=>{
         if(!ant.path){
           //let food=null;
           //for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(map[y][x]==TILE.FOOD) food={x,y};
           //food = foods[Math.floor(Math.random() * foods.size)];
           if(foods.size > 0){
              let target = getRandMap(foods);
              ant.target=target;
              ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),target.x,target.y);
              ant.pathIndex=0;
              if (!ant.path && map[target.y][target.x] == TILE.DIRT) {
                 foods.delete(get2dHash(target.x,target.y));
              }
           }else{
            let wander=getRandomNearbyEmptyTile(Math.floor(ant.x),Math.floor(ant.y), WANDER_DIST);
            if(wander){
              ant.target=wander;
              ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),wander.x,wander.y); ant.pathIndex=0;
            }
         }
         }
         if(ant.path && ant.pathIndex<ant.path.length) {
           let next=ant.path[ant.pathIndex];
           let dx=next.x+0.5 - ant.x, dy=next.y+0.5 - ant.y;
           let len=Math.sqrt(dx*dx+dy*dy);
           if(len<0.1){ ant.x=next.x+0.5; ant.y=next.y+0.5; ant.pathIndex++; }
           else{ ant.x+=0.04*dx/len; ant.y+=0.04*dy/len; }
         } else { ant.path=null; }

         let antX = Math.floor(ant.x), antY=Math.floor(ant.y);
         //dig
         if(map[antY][antX]==TILE.DIRT){
            map[antY][antX]=TILE.EMPTY;
            drawBackground(bgCtx);
         }
         if(!ant.carrying && foods.has(get2dHash(antX, antY))){
            ant.carrying=TILE.FOOD;
            foods.delete(get2dHash(antX, antY));
            
            ant.target={x:col.nest.x,y:col.nest.y};
            ant.path=findPath(antX,antY,col.nest.x,col.nest.y); ant.pathIndex=0;
         }
         
         if(ant.carrying == TILE.FOOD && antX == col.nest.x && antY == col.nest.y) {
            col.score++; ant.carrying=null; ant.target=null; ant.path=null;
            spawnEggNearNest(col, ANT_TYPE.WORKER);
         }
         
      });
      
      // soldiers: find spiders
      col.soldiers.forEach(ant=>{
         if(!ant.path){
           let food=null;
           for(let i=0; i < spiders.length; i++) {
               //if(spiders[i].timer == -1) {
               //   food = {spiders[i].x, spiders[i].y};
               //   break;
               //}
           }
           if(food){
               //let target=food[Math.floor(Math.random()*food.length)];
               ant.target = food;
               ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),food.x,food.y);
               ant.pathIndex=0;
           }else{
               let wander=getRandomNearbyEmptyTile(Math.floor(ant.x),Math.floor(ant.y),5);
               if(wander){
                 ant.target=wander;
                 ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),wander.x,wander.y); ant.pathIndex=0;
               }
            }
         }
         if(ant.path && ant.pathIndex<ant.path.length) {
           let next=ant.path[ant.pathIndex];
           let dx=next.x+0.5 - ant.x, dy=next.y+0.5 - ant.y;
           let len=Math.sqrt(dx*dx+dy*dy);
           if(len<0.1){ ant.x=next.x+0.5; ant.y=next.y+0.5; ant.pathIndex++; }
           else{ ant.x+=0.04*dx/len; ant.y+=0.04*dy/len; }
         } else { ant.path=null; }

         let antX = Math.floor(ant.x), antY=Math.floor(ant.y);
         //dig
         if(map[antY][antX]==TILE.DIRT) {
            map[antY][antX]=TILE.EMPTY;
            drawBackground(bgCtx);
         }
         /*if(!ant.carrying && map[antY][antX]==TILE.FOOD){
            ant.carrying=TILE.FOOD; map[antY][antX]=TILE.EMPTY;
            ant.target={x:col.nest.x,y:col.nest.y};
            ant.path=findPath(antX,antY,col.nest.x,col.nest.y); ant.pathIndex=0;
         }
         if(ant.carrying && antX == col.nest.x && antY == col.nest.y){
            col.score++; ant.carrying=null; ant.target=null; ant.path=null;
            spawnEggNearNest(col);
         }
         */
         
         //attack spider
         spiders.forEach(s=>{
            if(Math.abs(ant.x - s.x) < 0.7 && Math.abs(ant.y - s.y) < 0.7){
               //map[Math.floor(ant.y)][Math.floor(ant.x)] = TILE.DIRT;
               skulls.push({x:s.x,y:s.y,timer:300});
               //col.workers.splice(j,1);
               //spiderScore++;
               s.timer = EGG_HATCH_TIME;
            }
         });
         
      }); //END SOLDIER
  });

  // spiders chase nearest ant
  spiders.forEach(s=>{
    if (s.timer > 0) {
      return;
    }
    let nearest = getNearestAnt(s);
    if(nearest && nearest.dist < 5){
	  //chase
      if(!s.path || s.target.x!=Math.floor(nearest.ant.x)||s.target.y!=Math.floor(nearest.ant.y)){
        s.path = findPath(Math.floor(s.x),Math.floor(s.y),Math.floor(nearest.ant.x),Math.floor(nearest.ant.y));
        s.pathIndex = 0;
		  s.target = {x:Math.floor(nearest.ant.x), y:Math.floor(nearest.ant.y)};
      }
    }
	else {
		if(!s.target) {
			let wander=getRandomNearbyEmptyTile(Math.floor(s.x),Math.floor(s.y),5);
			if(wander){
			  s.target=wander;
			  s.path=findPath(Math.floor(s.x),Math.floor(s.y),wander.x,wander.y); s.pathIndex=0;
			}
		}
	}
    if(s.path && s.pathIndex<s.path.length){
	    let next = s.path[s.pathIndex];
		if (next.y < TILE_OPEN_SPACE || SPIDER_CAN_GO_BELOW) {
		
			let dx=next.x+0.5 - s.x, dy=next.y+0.5 - s.y;
			let len=Math.sqrt(dx*dx+dy*dy);
			if(len < 0.1) { 
				s.x = next.x+0.5;
				s.y = next.y+0.5;
				s.pathIndex++;
			}
			else{ 
				s.x+=0.02*dx/len; s.y+=0.02*dy/len;
			
			}
		}
		
	}
	else { 
		s.path=null;
		s.target=null;
	}
   
   if (s.cooldownTimer <= 0) {
      colonies.forEach(col=>{
         for(let j=col.workers.length-1; j>=0; j--){
            let w=col.workers[j];
            
            //spider eats ant
            if(Math.abs(w.x - s.x) < 0.7 && Math.abs(w.y - s.y) < 0.7){
               map[Math.floor(w.y)][Math.floor(w.x)]=TILE.DIRT;
               skulls.push({x:w.x,y:w.y,timer:300});
               col.workers.splice(j,1);
               spiderScore++;
               s.cooldownTimer = SPIDER_COOLDOWN;
            }
         }
      });
    }
/*
    if(player && Math.abs(player.x - s.x)<0.5 && Math.abs(player.y - s.y)<0.5){
	  //player death
      skulls.push({x:player.x,y:player.y,timer:30}); colonyScore=Math.max(0,colonyScore-1);
    }
	//worker death
    for(let j=workers.length-1;j>=0;j--){
      let w=workers[j];
      if(Math.abs(w.x - s.x)<0.5 && Math.abs(w.y - s.y)<0.5){
	  
		map[Math.floor(w.y)][Math.floor(w.x)]=TILE.DIRT;
        skulls.push({x:w.x,y:w.y,timer:30}); workers.splice(j,1); spiderScore++;
      }
    }
*/
  });
  
  for(let sk of skulls) sk.timer--;
  while(skulls.length&&skulls[0].timer<=0) skulls.shift();
}

function drawBackground(ctx) {
   ctx.clearRect(0,0,canvasWidth,canvasHeight);
   
   ctx.fillStyle="#5B3A1E";
   for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
     let t = map[y][x];
     if(t==TILE.DIRT) {
         ctx.fillStyle="#5B3A1E",ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
     }
     //food
     //else if(t==TILE.FOOD)ctx.fillStyle="green",ctx.fillRect(x*TILE_SIZE+5,y*TILE_SIZE+5,TILE_SIZE-10,TILE_SIZE-10);
     /*else if(t==TILE.NEST) {
       if(x == )
       ctx.fillStyle = "gray",ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
       ctx.fillStyle = "purple",ctx.fillRect(x*TILE_SIZE,(y*TILE_SIZE)+TILE_SIZE,TILE_SIZE,TILE_SIZE);
     }*/
    
     //else if(t==TILE.EGG){ctx.fillStyle="white";ctx.beginPath();ctx.arc(x*TILE_SIZE+TILE_SIZE/2,y*TILE_SIZE+TILE_SIZE/2,TILE_SIZE/3,0,Math.PI*2);ctx.fill();}
   }
}

function drawForeground(ctx) {
  ctx.clearRect(0,0,canvasWidth,canvasHeight);
  
  ctx.fillStyle="green";
  foods.forEach(food=>{
      if (food) ctx.fillRect(food.x*TILE_SIZE+5,food.y*TILE_SIZE+5,TILE_SIZE-10,TILE_SIZE-10);
  });
  colonies.forEach(col=>{
    
    ctx.fillStyle = "gray",ctx.fillRect(col.nest.x*TILE_SIZE,col.nest.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
    ctx.fillStyle = "purple",ctx.fillRect(col.nest.sX*TILE_SIZE,col.nest.sY*TILE_SIZE,TILE_SIZE,TILE_SIZE);
    
    ctx.fillStyle=col.color;
    
    //draw player
    ctx.beginPath();
    ctx.arc(col.player.x*TILE_SIZE,col.player.y*TILE_SIZE,TILE_SIZE/2-2,0,Math.PI*2);ctx.fill();
    
    //draw workers
    col.workers.forEach(w=>{
	   ctx.beginPath();
      ctx.arc(w.x*TILE_SIZE,w.y*TILE_SIZE,TILE_SIZE/2-3,0,Math.PI*2);ctx.fill();
	   if(w.carrying){
		   ctx.fillStyle=w.carrying==TILE.FOOD?"green":"white";
		   ctx.fillRect(w.x*TILE_SIZE+4,w.y*TILE_SIZE+4,6,6);
         ctx.fillStyle=col.color;
	   }
    });
    col.soldiers.forEach(ant=>{
      //ctx.fillStyle= blendColor(col.color, "#800080", 0.3); // 30% purple tint
      //ctx.fillStyle = "purple";
      //ctx.fillStyle = col.color;
	   ctx.beginPath();
      ctx.arc(ant.x*TILE_SIZE, ant.y*TILE_SIZE, TILE_SIZE * 0.45, 0, Math.PI*4);ctx.fill();
    });
	 if(col.player.carrying){
      ctx.fillStyle=col.player.carrying==TILE.FOOD?"green":"white";
      ctx.fillRect(col.player.x*TILE_SIZE+4,col.player.y*TILE_SIZE+4,6,6);
    }
    ctx.fillStyle = "white";
    col.eggs.forEach(egg=>{
      if (egg) {
         if(egg.carry) {
            ctx.fillRect(egg.x*TILE_SIZE+4,egg.y*TILE_SIZE+4,6,6);
         }
         else {
            ctx.fillRect(egg.x*TILE_SIZE+5,egg.y*TILE_SIZE+5,TILE_SIZE-10,TILE_SIZE-10);
         }
      }
    });
  });
  spiders.forEach(s=>{
      if(s.timer != -1) {
         ctx.fillStyle="white";
         ctx.fillRect(s.x*TILE_SIZE,s.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
      }
      else {
         ctx.fillStyle="darkblue";
         ctx.fillRect(s.x*TILE_SIZE,s.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
      }
  });
  for(let sk of skulls){ ctx.fillText("üíÄ",sk.x*TILE_SIZE,sk.y*TILE_SIZE);}
}

function drawDebug(ctx) {
   ctx.clearRect(0,0,canvasWidth,canvasHeight);
  
   //ctx.fillStyle="yellow";
   colonies.forEach(col=>{
      col.workers.forEach(w=>{
         if (w.path) {
            //ctx.fillStyle = fadeCssColor("yellow", Math.min(1.0 - (w.pathIndex / w.path.length), 0.3));
            ctx.fillStyle = hexToRgba("#ffff00", (1.0 - (w.pathIndex / w.path.length)) * 0.15);
            w.path.forEach(next=>{
               ctx.fillRect(next.x*TILE_SIZE,next.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
            });
         }
      });
   });
}
   
 
///////////////////////
/* Library Functions */
///////////////////////
let dirs = [
  {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},
  {x:1,y:1},{x:1,y:-1},{x:-1,y:1},{x:-1,y:-1}
];

// ÔøΩ A* pathfinding
function findPath(startX, startY, goalX, goalY){
  const open = new MinHeap();
  const openSet = new Set();
  const closed = new Set();
  const cameFrom = {};
  const gScore = {};
  const fScore = {};

  function key(x,y){ return y * COLS + x; }

  let startK = key(startX, startY);
  gScore[startK] = 0;
  fScore[startK] = Math.abs(goalX - startX) + Math.abs(goalY - startY);
  open.push({x: startX, y: startY, f: fScore[startK]});
  openSet.add(startK);

  while (!open.isEmpty()) {
    let current = open.pop();
    let currK = key(current.x, current.y);
    openSet.delete(currK);

    if (current.x === goalX && current.y === goalY) {
      let path = [{x: goalX, y: goalY}];
      while (cameFrom[key(path[0].x, path[0].y)]) {
        path.unshift(cameFrom[key(path[0].x, path[0].y)]);
      }
      return path;
    }

    closed.add(currK);
    for (let d of dirs) {
      let nx = current.x + d.x;
      let ny = current.y + d.y;
      if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
      if (map[ny][nx] == TILE.DIRT) continue;

      let nk = key(nx, ny);
      if (closed.has(nk)) continue;

      let tentativeG = gScore[currK] + 1;
      if (gScore[nk] === undefined || tentativeG < gScore[nk]) {
        cameFrom[nk] = {x: current.x, y: current.y};
        gScore[nk] = tentativeG;
        fScore[nk] = tentativeG + Math.abs(goalX - nx) + Math.abs(goalY - ny);
        if (!openSet.has(nk)) {
          open.push({x: nx, y: ny, f: fScore[nk]});
          openSet.add(nk);
        }
      }
    }
  }

  return null;
}

/*
function getNearestAnt(s){
  let ants=[player].concat(workers), nearest=null, minDist=999;
  for(let a of ants){
    let dx=a.x - s.x, dy=a.y - s.y, d=Math.sqrt(dx*dx+dy*dy);
    if(d<minDist){minDist=d; nearest=a;}
  }
  return nearest?{ant:nearest,dist:minDist}:null;
}
*/

function getNearestAnt(s) {
	let ants=colonies.flatMap(c=>[c.player,...c.workers]);
    let nearest=null,minDist=999;
    ants.forEach(a=>{
      let dx=a.x - s.x, dy=a.y - s.y, d=Math.sqrt(dx*dx+dy*dy);
      if(d<minDist){minDist=d; nearest=a;}
    });
	return nearest?{ant:nearest,dist:minDist}:null;
}

function spawnEggNearNest(col, type){
  let angle=Math.random()*Math.PI*2;
  let ex=col.nest.x+Math.floor(Math.cos(angle)*2);
  let ey=col.nest.y+Math.floor(Math.sin(angle)*2);
  if(ey>=0&&ey<ROWS&&ex>=0&&ex<COLS && (map[ey][ex]==TILE.DIRT||map[ey][ex]==TILE.EMPTY)) {
    map[ey][ex] = TILE.EMPTY;
	 col.eggs.set(get2dHash(ex,ey), {x:ex, y:ey, type:type, timer:EGG_HATCH_TIME, carry:false});
  }
}

// ‚úÖ helper: get random empty tile near (x,y) within radius, underground
function getRandomNearbyEmptyTile(centerX, centerY, radius){
  let tries=10;
  while(tries-- >0){
    let rx=centerX+Math.floor(Math.random()*radius*2 - radius);
    let ry=centerY+Math.floor(Math.random()*radius*2 - radius);
    if(rx>=0&&rx<COLS&&ry>=4&&ry<ROWS && map[ry][rx]!=TILE.DIRT){
      return {x:rx, y:ry};
    }
  }
  return null;
}

function get2dHash(x, y) {
   return `${x},${y}`;
}

function getRandMap(map) {
  const values = Array.from(map.values());
  if (values.length === 0) return undefined;
  const index = Math.floor(Math.random() * values.length);
  return values[index];
}

function findFoodAt(fx, fy) {
   foods.forEach(food=>{
      if(Math.abs(food.x - fx) < 0.7 && Math.abs(food.y - fy) < 0.7) {
         return food;
      }
   });
}

function blendColor(c1, c2, amount) {
    function hexToRgb(hex) {
        hex = hex.replace("#", "");
        return {
            r: parseInt(hex.substring(0,2), 16),
            g: parseInt(hex.substring(2,4), 16),
            b: parseInt(hex.substring(4,6), 16)
        };
    }
    function rgbToHex(r, g, b) {
        return "#" + 
            r.toString(16).padStart(2, '0') +
            g.toString(16).padStart(2, '0') +
            b.toString(16).padStart(2, '0');
    }

    let rgb1 = hexToRgb(c1);
    let rgb2 = hexToRgb(c2);

    // If the base color is too dark, brighten it slightly before blending
    const brightness = rgb1.r + rgb1.g + rgb1.b;
    if (brightness < 30) {
        rgb1.r = 60;
        rgb1.g = 40;
        rgb1.b = 60;
    }

    let r = Math.round(rgb1.r * (1 - amount) + rgb2.r * amount);
    let g = Math.round(rgb1.g * (1 - amount) + rgb2.g * amount);
    let b = Math.round(rgb1.b * (1 - amount) + rgb2.b * amount);

    return rgbToHex(r, g, b);
}

function toTransparentColor(color, alpha) {
  // Create a temporary canvas to convert any CSS color to RGB
  let tempCtx = document.createElement('canvas').getContext('2d');
  tempCtx.fillStyle = color;
  let computed = tempCtx.fillStyle;

  // computed is now in rgb(...) form
  let match = computed.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (!match) return color; // fallback to original color

  let [_, r, g, b] = match;
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function hexToRgba(hex, alpha = 1.0) {
  hex = hex.replace(/^#/, '');
  if (hex.length === 3) {
    hex = hex.split('').map(c => c + c).join('');
  }
  const r = parseInt(hex.substring(0,2), 16);
  const g = parseInt(hex.substring(2,4), 16);
  const b = parseInt(hex.substring(4,6), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

class MinHeap {
  constructor() { this.items = []; }
  push(node) {
    this.items.push(node);
    this.bubbleUp();
  }
  pop() {
    if (this.items.length < 2) return this.items.pop();
    const top = this.items[0];
    this.items[0] = this.items.pop();
    this.bubbleDown();
    return top;
  }
  bubbleUp() {
    let i = this.items.length - 1;
    while (i > 0) {
      let p = Math.floor((i - 1) / 2);
      if (this.items[i].f >= this.items[p].f) break;
      [this.items[i], this.items[p]] = [this.items[p], this.items[i]];
      i = p;
    }
  }
  bubbleDown() {
    let i = 0;
    const l = this.items.length;
    while (true) {
      let left = 2 * i + 1, right = 2 * i + 2, smallest = i;
      if (left < l && this.items[left].f < this.items[smallest].f) smallest = left;
      if (right < l && this.items[right].f < this.items[smallest].f) smallest = right;
      if (smallest === i) break;
      [this.items[i], this.items[smallest]] = [this.items[smallest], this.items[i]];
      i = smallest;
    }
  }
  isEmpty() { return this.items.length === 0; }
}

function gameLoop() {
  update();         // move ants, spawn eggs, AI
  drawForeground(fgCtx); // only redraw moving things
  if(showDebug) drawDebug(dbgCtx);
  requestAnimationFrame(gameLoop);
}

drawBackground(bgCtx);
gameLoop();

});
</script>

</body>
</html>
