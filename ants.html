<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Antfarm JS</title>
<style>
  body { margin:0; background:#333; color:#fff; font-family:sans-serif; }
  #gameCanvas { display:block; margin: 20px auto; background: #3A2414; border:4px solid #222; box-shadow:0 0 10px #000; }
  h1 { text-align:center; }
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
<h1>üêú Antfarm JS üêú</h1>
<canvas id="gameCanvas" width="1000" height="600"></canvas>
<script>
var jq = jQuery.noConflict();

jq(function(){
const canvas = jq("#gameCanvas")[0];
const ctx = canvas.getContext("2d");

const TILE_SIZE=20, COLS=Math.floor(canvas.width/TILE_SIZE), ROWS=Math.floor(canvas.height/TILE_SIZE);
const TILE={ EMPTY:0, DIRT:1, FOOD:2, NEST:3, EGG:4 };
const TILE_OPEN_SPACE=10;
const SPIDER_CAN_GO_BELOW = false;
const EGG_HATCH_TIME=1000;
const FOOD_SPAWN_INTERVAL=1800; // frames ~30s at 60fps
let foodSpawnTimer=FOOD_SPAWN_INTERVAL;
const FOOD_GROUP_SIZE=5;

const keys={}; // track keys
jq(document).keydown(e=>keys[e.key]=true);
jq(document).keyup(e=>keys[e.key]=false);


const NUM_SPIDERS=1;
const INIT_NUM_FOOD=30;
const map=[];
for(let y=0;y<ROWS;y++){
  let row=[]; for(let x=0;x<COLS;x++) row.push(y<TILE_OPEN_SPACE?TILE.EMPTY:TILE.DIRT);
  map.push(row);
}

// initial food on surface
for(let i=0;i<20;i++){
  let fx=Math.floor(Math.random()*COLS);
  let fy=Math.floor(Math.random()*TILE_OPEN_SPACE);
  map[fy][fx]=TILE.FOOD;
}

let spiderScore=0;
const colonies=[
  {name:"A", color:"black", nest:{}, eggs:[], workers:[], player:{}, score:0,playerTarget:null},
  {name:"B", color:"red", nest:{}, eggs:[], workers:[], player:{}, score:0,playerTarget:null}
];

//const eggs=[];
const spiders=[{x:4,y:2,target:null,path:null,pathIndex:0},{x:COLS-4,y:2,target:null,path:null,pathIndex:0}];
const skulls=[];

colonies.forEach((col)=>{
  let nx=0, ny=0;
  do{
    //subtract 2 for egg spawn distance
    nx = 2 + Math.floor(Math.random()*(COLS - 2));
    ny = 2 + TILE_OPEN_SPACE+Math.floor(Math.random()*(ROWS - TILE_OPEN_SPACE - 2));
  }while(map[ny][nx]!=TILE.DIRT);
  map[ny][nx]=TILE.NEST;
  col.nest={x:nx, y:ny};
  col.player={x:nx+0.5, y:ny+0.5, carrying:null};
  // spawn egg
  let ex=nx+1, ey=ny;
  if(map[ey][ex]==TILE.DIRT){
    map[ey][ex]=TILE.EGG;
    col.eggs.push({x:ex, y:ey, timer:EGG_HATCH_TIME});
  }
});

// click-to-move
jq(canvas).click(e=>{
  const rect=canvas.getBoundingClientRect();
  const mx=(e.clientX-rect.left)/TILE_SIZE;
  const my=(e.clientY-rect.top)/TILE_SIZE;
  colonies[0].playerTarget={x:mx, y:my};
});




function update(){
  foodSpawnTimer--;
  if(foodSpawnTimer<=0){
    foodSpawnTimer=FOOD_SPAWN_INTERVAL;
    for(let i=0;i<FOOD_GROUP_SIZE;i++){
      let fx=Math.floor(Math.random()*COLS);
      let fy=Math.floor(Math.random()*TILE_OPEN_SPACE);
      map[fy][fx]=TILE.FOOD;
    }
  }

  // eggs hatch
  /*
  for(let i=eggs.length-1;i>=0;i--){
    eggs[i].timer--;
    if(eggs[i].timer<=0){
      let col=colonies.find(c=>c.name==eggs[i].colony);
      col.workers.push({x:eggs[i].x+0.5, y:eggs[i].y+0.5, path:null, pathIndex:0});
      map[eggs[i].y][eggs[i].x]=TILE.EMPTY;
      eggs.splice(i,1);
    }
  }
  */
	
    // keyboard
	let dx=0, dy=0;
	let ex=0, ey=0;
	
		//player 1
		if(keys['a'])dx=-0.1;
		if(keys['d'])dx=0.1;
		if(keys['w'])dy=-0.1;
		if(keys['s'])dy=0.1;
		
		colonies[0].player.x=Math.max(0,Math.min(COLS-1,colonies[0].player.x+dx));
		colonies[0].player.y=Math.max(0,Math.min(ROWS-1,colonies[0].player.y+dy));
		
		// pickup/drop with 'e'
		if(keys['e']){
			keys['e']=false; // prevent repeat
			let tx=Math.floor(colonies[0].player.x), ty=Math.floor(colonies[0].player.y);
			if(!colonies[0].player.carrying){
			  if(map[ty][tx]==TILE.FOOD || map[ty][tx]==TILE.EGG){
				colonies[0].player.carrying=map[ty][tx];
				map[ty][tx]=TILE.EMPTY;
			  }
			}else{
			  if(map[ty][tx]==TILE.EMPTY){
				map[ty][tx] = colonies[0].player.carrying;
				colonies[0].player.carrying = null;
			  }
			}
		}
		
	
		//player 2
		if(keys['ArrowLeft'])ex=-0.1;
		if(keys['ArrowRight'])ex=0.1;
		if(keys['ArrowUp'])ey=-0.1;
		if(keys['ArrowDown'])ey=0.1;
		colonies[1].player.x=Math.max(0,Math.min(COLS-1,colonies[1].player.x+ex));
		colonies[1].player.y=Math.max(0,Math.min(ROWS-1,colonies[1].player.y+ey));
		

  colonies.forEach((col,idx)=>{
  
    //hatch eggs
	  for(let i=col.eggs.length-1;i>=0;i--){
		col.eggs[i].timer--;
		if(col.eggs[i].timer<=0){
		  col.workers.push({x:col.eggs[i].x+0.5, y:col.eggs[i].y+0.5, path:null, pathIndex:0});
		  map[col.eggs[i].y][col.eggs[i].x]=TILE.EMPTY;
		  col.eggs.splice(i,1);
		}
	  }
	  
	
    let player =col.player;
    


    // click target
    if(col.playerTarget){
      let ddx=col.playerTarget.x - player.x, ddy=col.playerTarget.y - player.y;
      let dist=Math.sqrt(ddx*ddx+ddy*ddy);
      if(dist>0.1) player.x+=0.1*ddx/dist, player.y+=0.1*ddy/dist;
      else col.playerTarget=null;
    }

    let tx=Math.floor(player.x), ty=Math.floor(player.y);
    if(map[ty][tx]==TILE.DIRT) map[ty][tx]=TILE.EMPTY;
	if(!player.carrying && (map[ty][tx]==TILE.FOOD||map[ty][tx]==TILE.EGG)){
		player.carrying=map[ty][tx]; map[ty][tx]=TILE.EMPTY;
	}
	if(tx==col.nest.x&&ty==col.nest.y && player.carrying){
		if(player.carrying==TILE.FOOD){ player.score++; spawnEggNearNest(col); }
		if(player.carrying==TILE.EGG){ col.workers.push({x:col.nest.x,y:col.nest.y,carrying:null,target:null,path:null,pathIndex:0}); }
		player.carrying=null;
	}

    // workers: find food
    col.workers.forEach(w=>{
      if(!w.path){
        let food=null;
        for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(map[y][x]==TILE.FOOD) food={x,y};
        if(food){
		  let target=food[Math.floor(Math.random()*food.length)];
          w.target=target;
          w.path=findPath(Math.floor(w.x),Math.floor(w.y),food.x,food.y);
          w.pathIndex=0;
        }else{
			let wander=getRandomNearbyEmptyTile(Math.floor(w.x),Math.floor(w.y),5);
			if(wander){
			  w.target=wander;
			  w.path=findPath(Math.floor(w.x),Math.floor(w.y),wander.x,wander.y); w.pathIndex=0;
			}
		}
      }
      if(w.path && w.pathIndex<w.path.length){
        let next=w.path[w.pathIndex];
        let dx=next.x+0.5 - w.x, dy=next.y+0.5 - w.y;
        let len=Math.sqrt(dx*dx+dy*dy);
        if(len<0.1){ w.x=next.x+0.5; w.y=next.y+0.5; w.pathIndex++; }
        else{ w.x+=0.04*dx/len; w.y+=0.04*dy/len; }
      } else { w.path=null; }

      let wx = Math.floor(w.x), wy=Math.floor(w.y);
      if(map[wy][wx]==TILE.DIRT) map[wy][wx]=TILE.EMPTY;
	if(!w.carrying && map[wy][wx]==TILE.FOOD){
		w.carrying=TILE.FOOD; map[wy][wx]=TILE.EMPTY;
		w.target={x:col.nest.x,y:col.nest.y};
		w.path=findPath(wx,wy,col.nest.x,col.nest.y); w.pathIndex=0;
	}
	if(w.carrying && wx==col.nest.x && wy==col.nest.y){
		col.score++; w.carrying=null; w.target=null; w.path=null;
		spawnEggNearNest(col);
	}
    });
  });

  // spiders chase nearest ant
  spiders.forEach(s=>{
    let nearest = getNearestAnt(s);
    if(nearest && nearest.dist < 5){
	  //chase
      if(!s.path || s.target.x!=Math.floor(nearest.ant.x)||s.target.y!=Math.floor(nearest.ant.y)){
        s.path = findPath(Math.floor(s.x),Math.floor(s.y),Math.floor(nearest.ant.x),Math.floor(nearest.ant.y));
        s.pathIndex = 0;
		s.target = {x:Math.floor(nearest.ant.x), y:Math.floor(nearest.ant.y)};
      }
    }
	else {
		if(!s.target) {
			let wander=getRandomNearbyEmptyTile(Math.floor(s.x),Math.floor(s.y),5);
			if(wander){
			  s.target=wander;
			  s.path=findPath(Math.floor(s.x),Math.floor(s.y),wander.x,wander.y); s.pathIndex=0;
			}
		}
	}
    if(s.path && s.pathIndex<s.path.length){
	    let next = s.path[s.pathIndex];
		if (next.y < TILE_OPEN_SPACE || SPIDER_CAN_GO_BELOW) {
		
			let dx=next.x+0.5 - s.x, dy=next.y+0.5 - s.y;
			let len=Math.sqrt(dx*dx+dy*dy);
			if(len < 0.1) { 
				s.x = next.x+0.5;
				s.y = next.y+0.5;
				s.pathIndex++;
			}
			else{ 
				s.x+=0.02*dx/len; s.y+=0.02*dy/len;
			
			}
		}
		
	}
	else { 
		s.path=null;
		s.target=null;
	}

    colonies.forEach(col=>{
		for(let j=col.workers.length-1; j>=0; j--){
			let w=col.workers[j];
			
			
			if(Math.abs(w.x - s.x)<0.7 && Math.abs(w.y - s.y)<0.7){
				map[Math.floor(w.y)][Math.floor(w.x)]=TILE.DIRT;
				skulls.push({x:w.x,y:w.y,timer:300});
				col.workers.splice(j,1);
				spiderScore++;
			}
		}
	});
/*
    if(player && Math.abs(player.x - s.x)<0.5 && Math.abs(player.y - s.y)<0.5){
	  //player death
      skulls.push({x:player.x,y:player.y,timer:30}); colonyScore=Math.max(0,colonyScore-1);
    }
	//worker death
    for(let j=workers.length-1;j>=0;j--){
      let w=workers[j];
      if(Math.abs(w.x - s.x)<0.5 && Math.abs(w.y - s.y)<0.5){
	  
		map[Math.floor(w.y)][Math.floor(w.x)]=TILE.DIRT;
        skulls.push({x:w.x,y:w.y,timer:30}); workers.splice(j,1); spiderScore++;
      }
    }
*/

  for(let sk of skulls) sk.timer--;
  while(skulls.length&&skulls[0].timer<=0) skulls.shift();
  });
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
    let t=map[y][x];
    if(t==TILE.DIRT)ctx.fillStyle="#5B3A1E",ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
    else if(t==TILE.FOOD)ctx.fillStyle="green",ctx.fillRect(x*TILE_SIZE+5,y*TILE_SIZE+5,TILE_SIZE-10,TILE_SIZE-10);
    else if(t==TILE.NEST)ctx.fillStyle="gray",ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
    else if(t==TILE.EGG){ctx.fillStyle="white";ctx.beginPath();ctx.arc(x*TILE_SIZE+TILE_SIZE/2,y*TILE_SIZE+TILE_SIZE/2,TILE_SIZE/3,0,Math.PI*2);ctx.fill();}
  }
  colonies.forEach(col=>{
    ctx.fillStyle=col.color; ctx.beginPath();
    ctx.arc(col.player.x*TILE_SIZE,col.player.y*TILE_SIZE,TILE_SIZE/2-2,0,Math.PI*2);ctx.fill();
    col.workers.forEach(w=>{
      ctx.fillStyle=col.color;
	  ctx.beginPath();
      ctx.arc(w.x*TILE_SIZE,w.y*TILE_SIZE,TILE_SIZE/2-3,0,Math.PI*2);ctx.fill();
	  if(w.carrying){
		ctx.fillStyle=w.carrying==TILE.FOOD?"green":"white";
		ctx.fillRect(w.x*TILE_SIZE+4,w.y*TILE_SIZE+4,6,6);
	  }
    });
	if(col.player.carrying){
      ctx.fillStyle=col.player.carrying==TILE.FOOD?"green":"white";
      ctx.fillRect(col.player.x*TILE_SIZE+4,col.player.y*TILE_SIZE+4,6,6);
    }
  });
  spiders.forEach(s=>{ctx.fillStyle="darkblue";ctx.fillRect(s.x*TILE_SIZE,s.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);});
  for(let sk of skulls){ ctx.fillText("üíÄ",sk.x*TILE_SIZE,sk.y*TILE_SIZE);}
}




///////////////////////
/* Library Functions */
///////////////////////


// ÔøΩ A* pathfinding
function findPath(startX, startY, goalX, goalY){
  const open=[], closed={}, cameFrom={};
  const gScore={}, fScore={};
  function key(x,y){ return x+','+y; }

  let startK=key(startX,startY);
  gScore[startK]=0;
  fScore[startK]=Math.abs(goalX-startX)+Math.abs(goalY-startY);
  open.push({x:startX,y:startY,f:fScore[startK]});

  while(open.length>0){
    open.sort((a,b)=>a.f-b.f);
    let current=open.shift();
    let currK=key(current.x,current.y);
    if(current.x==goalX && current.y==goalY){
      let path=[{x:goalX,y:goalY}];
      while(cameFrom[key(path[0].x,path[0].y)]){
        path.unshift(cameFrom[key(path[0].x,path[0].y)]);
      }
      return path;
    }
    closed[currK]=true;
    let dirs=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    for(let d of dirs){
      let nx=current.x+d.x, ny=current.y+d.y, nk=key(nx,ny);
      if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
      if(map[ny][nx]==TILE.DIRT) continue;
      if(closed[nk]) continue;
      let tentativeG=gScore[currK]+1;
      if(gScore[nk]==undefined||tentativeG<gScore[nk]){
        cameFrom[nk]={x:current.x,y:current.y};
        gScore[nk]=tentativeG;
        fScore[nk]=tentativeG+Math.abs(goalX-nx)+Math.abs(goalY-ny);
        if(!open.find(n=>n.x==nx&&n.y==ny)) open.push({x:nx,y:ny,f:fScore[nk]});
      }
    }
  }
  return null;
}

/*
function getNearestAnt(s){
  let ants=[player].concat(workers), nearest=null, minDist=999;
  for(let a of ants){
    let dx=a.x - s.x, dy=a.y - s.y, d=Math.sqrt(dx*dx+dy*dy);
    if(d<minDist){minDist=d; nearest=a;}
  }
  return nearest?{ant:nearest,dist:minDist}:null;
}
*/

function getNearestAnt(s) {
	let ants=colonies.flatMap(c=>[c.player,...c.workers]);
    let nearest=null,minDist=999;
    ants.forEach(a=>{
      let dx=a.x - s.x, dy=a.y - s.y, d=Math.sqrt(dx*dx+dy*dy);
      if(d<minDist){minDist=d; nearest=a;}
    });
	return nearest?{ant:nearest,dist:minDist}:null;
}

function spawnEggNearNest(col){
  let angle=Math.random()*Math.PI*2;
  let ex=col.nest.x+Math.floor(Math.cos(angle)*2);
  let ey=col.nest.y+Math.floor(Math.sin(angle)*2);
  if(ey>=0&&ey<ROWS&&ex>=0&&ex<COLS && (map[ey][ex]==TILE.DIRT||map[ey][ex]==TILE.EMPTY)) {
    map[ey][ex]=TILE.EGG;
	col.eggs.push({x:ex, y:ey, timer:EGG_HATCH_TIME});
  }
}

// ‚úÖ helper: get random empty tile near (x,y) within radius, underground
function getRandomNearbyEmptyTile(centerX, centerY, radius){
  let tries=10;
  while(tries-- >0){
    let rx=centerX+Math.floor(Math.random()*radius*2 - radius);
    let ry=centerY+Math.floor(Math.random()*radius*2 - radius);
    if(rx>=0&&rx<COLS&&ry>=4&&ry<ROWS && map[ry][rx]!=TILE.DIRT){
      return {x:rx, y:ry};
    }
  }
  return null;
}

function loop(){update();draw();requestAnimationFrame(loop);}
loop();
});
</script>

</body>
</html>
