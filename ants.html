<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Antfarm JS</title>
<style>
  body { margin:0; background:#333; color:#fff; font-family:sans-serif; }
  #gameCanvas { display:block; margin: 20px auto; background: #3A2414; border:4px solid #222; box-shadow:0 0 10px #000; }
  h3 { text-align:center; }
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
<h3>üêú Antfarm JS üêú</h3>
<canvas id="gameCanvas" width="1300" height="600"></canvas>
<script>
var jq = jQuery.noConflict();

jq(function(){
const canvas = jq("#gameCanvas")[0];
const ctx = canvas.getContext("2d");

const TILE_SIZE=20, COLS=Math.floor(canvas.width/TILE_SIZE), ROWS=Math.floor(canvas.height/TILE_SIZE);
const TILE={ EMPTY:0, DIRT:1, FOOD:2, NEST:3, EGG:4 };
const ANT_TYPE = { QUEEN:0, WORKER:1, SOLDIER:2, FEMALE:3, MALE:4 };
const TILE_OPEN_SPACE=10;
const SPIDER_CAN_GO_BELOW = false;
const EGG_HATCH_TIME=1000;
const FOOD_SPAWN_INTERVAL=1800; // frames ~30s at 60fps
let foodSpawnTimer=FOOD_SPAWN_INTERVAL;
const FOOD_GROUP_SIZE=5;

const keys={}; // track keys
jq(document).keydown(e=>keys[e.key]=true);
jq(document).keyup(e=>keys[e.key]=false);


const NUM_SPIDERS=1;
const INIT_NUM_FOOD=30;
const map=[];
for(let y=0;y<ROWS;y++){
  let row=[]; for(let x=0;x<COLS;x++) row.push(y<TILE_OPEN_SPACE?TILE.EMPTY:TILE.DIRT);
  map.push(row);
}

// initial food on surface
for(let i=0;i<20;i++){
  let fx=Math.floor(Math.random()*COLS);
  let fy=Math.floor(Math.random()*TILE_OPEN_SPACE);
  map[fy][fx]=TILE.FOOD;
}

let spiderScore=0;
const colonies=[
  {name:"A", color:"black", nest:{}, eggs:[], workers:[], soldiers:[], player:{}, score:0, playerTarget:null},
  {name:"B", color:"red", nest:{}, eggs:[], workers:[], soldiers:[], player:{}, score:0, playerTarget:null}
];


const spiders=[{x:4,y:2,target:null,path:null,pathIndex:0, timer:EGG_HATCH_TIME},{x:COLS-4,y:2,target:null,path:null,pathIndex:0, timer:EGG_HATCH_TIME}];
const skulls=[];

colonies.forEach((col)=>{
  let nx=0, ny=0;
  do{
    //subtract 2 for egg spawn distance
    nx = 2 + Math.floor(Math.random()*(COLS - 4));
    ny = 2 + TILE_OPEN_SPACE + Math.floor(Math.random()*(ROWS - TILE_OPEN_SPACE - 4));
  }while(map[ny][nx]!=TILE.DIRT);
  map[ny][nx]=TILE.NEST;
  map[ny + 1][nx]=TILE.NEST;
  col.nest={x:nx, y:ny, sX:nx, sY:ny+1};
  
  //place player
  col.player={x:nx+0.5, y:ny+0.5, carrying:null};
  
  // spawn egg
  let ex = nx+1, ey = ny;
  if(map[ey][ex] == TILE.DIRT) {
    map[ey][ex] = TILE.EGG;
    col.eggs.push({x:ex, y:ey, type:ANT_TYPE.WORKER, timer:EGG_HATCH_TIME});
  }
});

// click-to-move
jq(canvas).click(e=>{
  const rect=canvas.getBoundingClientRect();
  const mx=(e.clientX-rect.left)/TILE_SIZE;
  const my=(e.clientY-rect.top)/TILE_SIZE;
  colonies[0].playerTarget={x:mx, y:my};
});




function update(){
  foodSpawnTimer--;
  if(foodSpawnTimer<=0){
    foodSpawnTimer=FOOD_SPAWN_INTERVAL;
    for(let i=0;i<FOOD_GROUP_SIZE;i++){
      let fx=Math.floor(Math.random()*COLS);
      let fy=Math.floor(Math.random()*TILE_OPEN_SPACE);
      map[fy][fx]=TILE.FOOD;
    }
  }

  // eggs hatch
  /*
  for(let i=eggs.length-1;i>=0;i--){
    eggs[i].timer--;
    if(eggs[i].timer<=0){
      let col=colonies.find(c=>c.name==eggs[i].colony);
      col.workers.push({x:eggs[i].x+0.5, y:eggs[i].y+0.5, path:null, pathIndex:0});
      map[eggs[i].y][eggs[i].x]=TILE.EMPTY;
      eggs.splice(i,1);
    }
  }
  */
	
    // keyboard
	let dx=0, dy=0;
	let ex=0, ey=0;
	
	//player 1
	if(keys['a'])dx=-0.1;
	if(keys['d'])dx=0.1;
	if(keys['w'])dy=-0.1;
	if(keys['s'])dy=0.1;
	
	colonies[0].player.x=Math.max(0,Math.min(COLS-1,colonies[0].player.x+dx));
	colonies[0].player.y=Math.max(0,Math.min(ROWS-1,colonies[0].player.y+dy));
	
	// pickup/drop with 'e'
	if(keys['e']){
		keys['e']=false; // prevent repeat
		let tx=Math.floor(colonies[0].player.x), ty=Math.floor(colonies[0].player.y);
		if(!colonies[0].player.carrying){
		  if(map[ty][tx]==TILE.FOOD || map[ty][tx]==TILE.EGG){
			colonies[0].player.carrying=map[ty][tx];
			map[ty][tx]=TILE.EMPTY;
		  }
		}else{
		  if(map[ty][tx]==TILE.EMPTY){
			map[ty][tx] = colonies[0].player.carrying;
			colonies[0].player.carrying = null;
		  }
		}
	}
	

	//player 2
	if(keys['ArrowLeft'])ex = -0.1;
	if(keys['ArrowRight'])ex = 0.1;
	if(keys['ArrowUp'])ey = -0.1;
	if(keys['ArrowDown'])ey = 0.1;
	colonies[1].player.x=Math.max(0,Math.min(COLS-1,colonies[1].player.x+ex));
	colonies[1].player.y=Math.max(0,Math.min(ROWS-1,colonies[1].player.y+ey));
		

   colonies.forEach((col,idx)=>{
  
      //hatch eggs
      for(let i = col.eggs.length-1; i >= 0; i--) {
         col.eggs[i].timer--;
         if(col.eggs[i].timer<=0){
            if(col.eggs[i].type == ANT_TYPE.SOLDIER) {
               col.soldiers.push({x:col.eggs[i].x+0.5, y:col.eggs[i].y+0.5, path:null, pathIndex:0, type:ANT_TYPE.SOLDIER});
            }
            else {
               col.workers.push({x:col.eggs[i].x+0.5, y:col.eggs[i].y+0.5, path:null, pathIndex:0, type:ANT_TYPE.WORKER});
            }
            map[col.eggs[i].y][col.eggs[i].x] = TILE.EMPTY;
            col.eggs.splice(i,1);
         }
      }
      //hatch spiders
      for(let i = spiders.length-1; i >= 0; i--) {
         if(spiders[i].timer == -1) {
            break;
         }
         else if(spiders[i].timer <= 0){
            spiders[i].timer = -1;
         }
         else {
            spiders[i].timer--;
         }
      }
        
      
       let player = col.player;
       


       // click target
       if(col.playerTarget){
         let ddx=col.playerTarget.x - player.x, ddy=col.playerTarget.y - player.y;
         let dist=Math.sqrt(ddx*ddx+ddy*ddy);
         if(dist>0.1) player.x+=0.1*ddx/dist, player.y+=0.1*ddy/dist;
         else col.playerTarget=null;
       }

      let tx=Math.floor(player.x), ty=Math.floor(player.y);
      if(map[ty][tx]==TILE.DIRT) map[ty][tx]=TILE.EMPTY;
      if(!player.carrying && (map[ty][tx]==TILE.FOOD||map[ty][tx]==TILE.EGG)){
         player.carrying=map[ty][tx]; map[ty][tx]=TILE.EMPTY;
      }
      if(tx==col.nest.x&&ty==col.nest.y && player.carrying){
         if(player.carrying==TILE.FOOD){ player.score++; spawnEggNearNest(col, ANT_TYPE.WORKER); }
         if(player.carrying==TILE.EGG){ 
            col.workers.push({x:col.nest.x, y:col.nest.y, carrying:null, target:null, path:null, pathIndex:0, type:ANT_TYPE.WORKER});
         }
         player.carrying=null;
      }
      if(tx==col.nest.sX&&ty==col.nest.sY && player.carrying) {
         if(player.carrying==TILE.FOOD){ player.score++; spawnEggNearNest(col, ANT_TYPE.SOLDIER); }
         if(player.carrying==TILE.EGG) {
            col.soldiers.push({x:col.nest.sX, y:col.nest.sY, carrying:null, target:null, path:null, pathIndex:0, type:ANT_TYPE.SOLDIER});
         }
         player.carrying=null;
      }

      // workers: find food
      col.workers.forEach(ant=>{
         if(!ant.path){
           let food=null;
           for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(map[y][x]==TILE.FOOD) food={x,y};
           if(food){
           let target=food[Math.floor(Math.random()*food.length)];
             ant.target=target;
             ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),food.x,food.y);
             ant.pathIndex=0;
           }else{
            let wander=getRandomNearbyEmptyTile(Math.floor(ant.x),Math.floor(ant.y),5);
            if(wander){
              ant.target=wander;
              ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),wander.x,wander.y); ant.pathIndex=0;
            }
         }
         }
         if(ant.path && ant.pathIndex<ant.path.length) {
           let next=ant.path[ant.pathIndex];
           let dx=next.x+0.5 - ant.x, dy=next.y+0.5 - ant.y;
           let len=Math.sqrt(dx*dx+dy*dy);
           if(len<0.1){ ant.x=next.x+0.5; ant.y=next.y+0.5; ant.pathIndex++; }
           else{ ant.x+=0.04*dx/len; ant.y+=0.04*dy/len; }
         } else { ant.path=null; }

         let antX = Math.floor(ant.x), antY=Math.floor(ant.y);
         if(map[antY][antX]==TILE.DIRT) map[antY][antX]=TILE.EMPTY;
         if(!ant.carrying && map[antY][antX]==TILE.FOOD){
            ant.carrying=TILE.FOOD; map[antY][antX]=TILE.EMPTY;
            ant.target={x:col.nest.x,y:col.nest.y};
            ant.path=findPath(antX,antY,col.nest.x,col.nest.y); ant.pathIndex=0;
         }
         if(ant.carrying && antX == col.nest.x && antY == col.nest.y){
            col.score++; ant.carrying=null; ant.target=null; ant.path=null;
            spawnEggNearNest(col);
         }
      });
      
      // soldiers: find spiders
      col.soldiers.forEach(ant=>{
         if(!ant.path){
           let food=null;
           for(let i=0; i < spiders.length; i++) {
               //if(spiders[i].timer == -1) {
               //   food = {spiders[i].x, spiders[i].y};
               //   break;
               //}
           }
           if(food){
               //let target=food[Math.floor(Math.random()*food.length)];
               ant.target = food;
               ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),food.x,food.y);
               ant.pathIndex=0;
           }else{
               let wander=getRandomNearbyEmptyTile(Math.floor(ant.x),Math.floor(ant.y),5);
               if(wander){
                 ant.target=wander;
                 ant.path=findPath(Math.floor(ant.x),Math.floor(ant.y),wander.x,wander.y); ant.pathIndex=0;
               }
            }
         }
         if(ant.path && ant.pathIndex<ant.path.length) {
           let next=ant.path[ant.pathIndex];
           let dx=next.x+0.5 - ant.x, dy=next.y+0.5 - ant.y;
           let len=Math.sqrt(dx*dx+dy*dy);
           if(len<0.1){ ant.x=next.x+0.5; ant.y=next.y+0.5; ant.pathIndex++; }
           else{ ant.x+=0.04*dx/len; ant.y+=0.04*dy/len; }
         } else { ant.path=null; }

         let antX = Math.floor(ant.x), antY=Math.floor(ant.y);
         if(map[antY][antX]==TILE.DIRT) map[antY][antX]=TILE.EMPTY;
         /*if(!ant.carrying && map[antY][antX]==TILE.FOOD){
            ant.carrying=TILE.FOOD; map[antY][antX]=TILE.EMPTY;
            ant.target={x:col.nest.x,y:col.nest.y};
            ant.path=findPath(antX,antY,col.nest.x,col.nest.y); ant.pathIndex=0;
         }
         if(ant.carrying && antX == col.nest.x && antY == col.nest.y){
            col.score++; ant.carrying=null; ant.target=null; ant.path=null;
            spawnEggNearNest(col);
         }
         */
         
         //attack spider
         spiders.forEach(s=>{
            if(Math.abs(ant.x - s.x) < 0.7 && Math.abs(ant.y - s.y) < 0.7){
               //map[Math.floor(ant.y)][Math.floor(ant.x)] = TILE.DIRT;
               skulls.push({x:s.x,y:s.y,timer:300});
               //col.workers.splice(j,1);
               //spiderScore++;
               s.timer = EGG_HATCH_TIME;
            }
         });
         
      }); //END SOLDIER
  });

  // spiders chase nearest ant
  spiders.forEach(s=>{
    if (s.timer != -1) {
      return;
    }
    let nearest = getNearestAnt(s);
    if(nearest && nearest.dist < 5){
	  //chase
      if(!s.path || s.target.x!=Math.floor(nearest.ant.x)||s.target.y!=Math.floor(nearest.ant.y)){
        s.path = findPath(Math.floor(s.x),Math.floor(s.y),Math.floor(nearest.ant.x),Math.floor(nearest.ant.y));
        s.pathIndex = 0;
		  s.target = {x:Math.floor(nearest.ant.x), y:Math.floor(nearest.ant.y)};
      }
    }
	else {
		if(!s.target) {
			let wander=getRandomNearbyEmptyTile(Math.floor(s.x),Math.floor(s.y),5);
			if(wander){
			  s.target=wander;
			  s.path=findPath(Math.floor(s.x),Math.floor(s.y),wander.x,wander.y); s.pathIndex=0;
			}
		}
	}
    if(s.path && s.pathIndex<s.path.length){
	    let next = s.path[s.pathIndex];
		if (next.y < TILE_OPEN_SPACE || SPIDER_CAN_GO_BELOW) {
		
			let dx=next.x+0.5 - s.x, dy=next.y+0.5 - s.y;
			let len=Math.sqrt(dx*dx+dy*dy);
			if(len < 0.1) { 
				s.x = next.x+0.5;
				s.y = next.y+0.5;
				s.pathIndex++;
			}
			else{ 
				s.x+=0.02*dx/len; s.y+=0.02*dy/len;
			
			}
		}
		
	}
	else { 
		s.path=null;
		s.target=null;
	}

   colonies.forEach(col=>{
		for(let j=col.workers.length-1; j>=0; j--){
			let w=col.workers[j];
			
			
			if(Math.abs(w.x - s.x) < 0.7 && Math.abs(w.y - s.y) < 0.7){
				map[Math.floor(w.y)][Math.floor(w.x)]=TILE.DIRT;
				skulls.push({x:w.x,y:w.y,timer:300});
				col.workers.splice(j,1);
				spiderScore++;
			}
		}
	});
/*
    if(player && Math.abs(player.x - s.x)<0.5 && Math.abs(player.y - s.y)<0.5){
	  //player death
      skulls.push({x:player.x,y:player.y,timer:30}); colonyScore=Math.max(0,colonyScore-1);
    }
	//worker death
    for(let j=workers.length-1;j>=0;j--){
      let w=workers[j];
      if(Math.abs(w.x - s.x)<0.5 && Math.abs(w.y - s.y)<0.5){
	  
		map[Math.floor(w.y)][Math.floor(w.x)]=TILE.DIRT;
        skulls.push({x:w.x,y:w.y,timer:30}); workers.splice(j,1); spiderScore++;
      }
    }
*/

  for(let sk of skulls) sk.timer--;
  while(skulls.length&&skulls[0].timer<=0) skulls.shift();
  });
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
     let t=map[y][x];
     if(t==TILE.DIRT)ctx.fillStyle="#5B3A1E",ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
     else if(t==TILE.FOOD)ctx.fillStyle="green",ctx.fillRect(x*TILE_SIZE+5,y*TILE_SIZE+5,TILE_SIZE-10,TILE_SIZE-10);
     /*else if(t==TILE.NEST) {
       if(x == )
       ctx.fillStyle = "gray",ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
       ctx.fillStyle = "purple",ctx.fillRect(x*TILE_SIZE,(y*TILE_SIZE)+TILE_SIZE,TILE_SIZE,TILE_SIZE);
     }*/
    
     else if(t==TILE.EGG){ctx.fillStyle="white";ctx.beginPath();ctx.arc(x*TILE_SIZE+TILE_SIZE/2,y*TILE_SIZE+TILE_SIZE/2,TILE_SIZE/3,0,Math.PI*2);ctx.fill();}
  }
  colonies.forEach(col=>{
    
    ctx.fillStyle = "gray",ctx.fillRect(col.nest.x*TILE_SIZE,col.nest.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
    ctx.fillStyle = "purple",ctx.fillRect(col.nest.sX*TILE_SIZE,col.nest.sY*TILE_SIZE,TILE_SIZE,TILE_SIZE);
    
    ctx.fillStyle=col.color; ctx.beginPath();
    ctx.arc(col.player.x*TILE_SIZE,col.player.y*TILE_SIZE,TILE_SIZE/2-2,0,Math.PI*2);ctx.fill();
    col.workers.forEach(w=>{
      ctx.fillStyle=col.color;
	   ctx.beginPath();
      ctx.arc(w.x*TILE_SIZE,w.y*TILE_SIZE,TILE_SIZE/2-3,0,Math.PI*2);ctx.fill();
	   if(w.carrying){
		   ctx.fillStyle=w.carrying==TILE.FOOD?"green":"white";
		   ctx.fillRect(w.x*TILE_SIZE+4,w.y*TILE_SIZE+4,6,6);
	   }
    });
    col.soldiers.forEach(ant=>{
      //ctx.fillStyle= blendColor(col.color, "#800080", 0.3); // 30% purple tint
      //ctx.fillStyle = "purple";
      ctx.fillStyle = col.color;
	   ctx.beginPath();
      ctx.arc(ant.x*TILE_SIZE, ant.y*TILE_SIZE, TILE_SIZE * 0.45, 0, Math.PI*4);ctx.fill();
    });
	if(col.player.carrying){
      ctx.fillStyle=col.player.carrying==TILE.FOOD?"green":"white";
      ctx.fillRect(col.player.x*TILE_SIZE+4,col.player.y*TILE_SIZE+4,6,6);
    }
  });
  spiders.forEach(s=>{
      if(s.timer != -1) {
         ctx.fillStyle="white";ctx.fillRect(s.x*TILE_SIZE,s.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
      }
      else {
         ctx.fillStyle="darkblue";ctx.fillRect(s.x*TILE_SIZE,s.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
      }
  });
  for(let sk of skulls){ ctx.fillText("üíÄ",sk.x*TILE_SIZE,sk.y*TILE_SIZE);}
}




///////////////////////
/* Library Functions */
///////////////////////


// ÔøΩ A* pathfinding
function findPath(startX, startY, goalX, goalY){
  const open=[], closed={}, cameFrom={};
  const gScore={}, fScore={};
  function key(x,y){ return x+','+y; }

  let startK=key(startX,startY);
  gScore[startK]=0;
  fScore[startK]=Math.abs(goalX-startX)+Math.abs(goalY-startY);
  open.push({x:startX,y:startY,f:fScore[startK]});

  while(open.length>0){
    open.sort((a,b)=>a.f-b.f);
    let current=open.shift();
    let currK=key(current.x,current.y);
    if(current.x==goalX && current.y==goalY){
      let path=[{x:goalX,y:goalY}];
      while(cameFrom[key(path[0].x,path[0].y)]){
        path.unshift(cameFrom[key(path[0].x,path[0].y)]);
      }
      return path;
    }
    closed[currK]=true;
    let dirs=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    for(let d of dirs){
      let nx=current.x+d.x, ny=current.y+d.y, nk=key(nx,ny);
      if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
      if(map[ny][nx]==TILE.DIRT) continue;
      if(closed[nk]) continue;
      let tentativeG=gScore[currK]+1;
      if(gScore[nk]==undefined||tentativeG<gScore[nk]){
        cameFrom[nk]={x:current.x,y:current.y};
        gScore[nk]=tentativeG;
        fScore[nk]=tentativeG+Math.abs(goalX-nx)+Math.abs(goalY-ny);
        if(!open.find(n=>n.x==nx&&n.y==ny)) open.push({x:nx,y:ny,f:fScore[nk]});
      }
    }
  }
  return null;
}

/*
function getNearestAnt(s){
  let ants=[player].concat(workers), nearest=null, minDist=999;
  for(let a of ants){
    let dx=a.x - s.x, dy=a.y - s.y, d=Math.sqrt(dx*dx+dy*dy);
    if(d<minDist){minDist=d; nearest=a;}
  }
  return nearest?{ant:nearest,dist:minDist}:null;
}
*/

function getNearestAnt(s) {
	let ants=colonies.flatMap(c=>[c.player,...c.workers]);
    let nearest=null,minDist=999;
    ants.forEach(a=>{
      let dx=a.x - s.x, dy=a.y - s.y, d=Math.sqrt(dx*dx+dy*dy);
      if(d<minDist){minDist=d; nearest=a;}
    });
	return nearest?{ant:nearest,dist:minDist}:null;
}

function spawnEggNearNest(col, type){
  let angle=Math.random()*Math.PI*2;
  let ex=col.nest.x+Math.floor(Math.cos(angle)*2);
  let ey=col.nest.y+Math.floor(Math.sin(angle)*2);
  if(ey>=0&&ey<ROWS&&ex>=0&&ex<COLS && (map[ey][ex]==TILE.DIRT||map[ey][ex]==TILE.EMPTY)) {
    map[ey][ex]=TILE.EGG;
	 col.eggs.push({x:ex, y:ey, type:type, timer:EGG_HATCH_TIME});
  }
}

// ‚úÖ helper: get random empty tile near (x,y) within radius, underground
function getRandomNearbyEmptyTile(centerX, centerY, radius){
  let tries=10;
  while(tries-- >0){
    let rx=centerX+Math.floor(Math.random()*radius*2 - radius);
    let ry=centerY+Math.floor(Math.random()*radius*2 - radius);
    if(rx>=0&&rx<COLS&&ry>=4&&ry<ROWS && map[ry][rx]!=TILE.DIRT){
      return {x:rx, y:ry};
    }
  }
  return null;
}

function blendColor(c1, c2, amount) {
    function hexToRgb(hex) {
        hex = hex.replace("#", "");
        return {
            r: parseInt(hex.substring(0,2), 16),
            g: parseInt(hex.substring(2,4), 16),
            b: parseInt(hex.substring(4,6), 16)
        };
    }
    function rgbToHex(r, g, b) {
        return "#" + 
            r.toString(16).padStart(2, '0') +
            g.toString(16).padStart(2, '0') +
            b.toString(16).padStart(2, '0');
    }

    let rgb1 = hexToRgb(c1);
    let rgb2 = hexToRgb(c2);

    // If the base color is too dark, brighten it slightly before blending
    const brightness = rgb1.r + rgb1.g + rgb1.b;
    if (brightness < 30) {
        rgb1.r = 60;
        rgb1.g = 40;
        rgb1.b = 60;
    }

    let r = Math.round(rgb1.r * (1 - amount) + rgb2.r * amount);
    let g = Math.round(rgb1.g * (1 - amount) + rgb2.g * amount);
    let b = Math.round(rgb1.b * (1 - amount) + rgb2.b * amount);

    return rgbToHex(r, g, b);
}

function loop(){update();draw();requestAnimationFrame(loop);}
loop();
});
</script>

</body>
</html>
